import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";
import { randomUUID } from "node:crypto";
import { type AppType } from "../types";
import { db } from "../db";
import { isUserBlocked, filterBlockedUsers } from "./moderation";

const friendsRouter = new Hono<AppType>();

// ============================================
// GET /api/friends - Get user's friends list
// ============================================
friendsRouter.get("/", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  // Get blocked users
  const blockedUsers = await db.user_block.findMany({
    where: { blockerId: user.id },
    select: { blockedId: true },
  });
  const blockedIds = blockedUsers.map((b) => b.blockedId);

  // Get all accepted friendships where user is either initiator or receiver (excluding blocked)
  const friendships = await db.friendship.findMany({
    where: {
      OR: [
        { initiatorId: user.id, status: "ACCEPTED", receiverId: { notIn: blockedIds } },
        { receiverId: user.id, status: "ACCEPTED", initiatorId: { notIn: blockedIds } },
      ],
    },
    include: {
      user_friendship_initiatorIdTouser: {
        include: {
          profile: true,
        },
      },
      user_friendship_receiverIdTouser: {
        include: {
          profile: true,
        },
      },
    },
  });

  // Format friends list
  const friends = friendships.map((friendship) => {
    const friend = friendship.initiatorId === user.id ? friendship.user_friendship_receiverIdTouser : friendship.user_friendship_initiatorIdTouser;
    const profile = friend.profile;

    return {
      id: friend.id,
      email: friend.email,
      displayName: profile?.displayName || friend.email?.split("@")[0] || "User",
      avatar: profile?.avatar || null,
      bio: profile?.bio || null,
      friendshipId: friendship.id,
      friendsSince: friendship.createdAt,
    };
  });

  return c.json({ friends });
});

// ============================================
// GET /api/friends/requests - Get pending friend requests
// ============================================
friendsRouter.get("/requests", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  // Get pending requests where user is the receiver
  const requests = await db.friendship.findMany({
    where: {
      receiverId: user.id,
      status: "PENDING",
    },
    include: {
      user_friendship_initiatorIdTouser: {
        include: {
          profile: true,
        },
      },
    },
    orderBy: {
      createdAt: "desc",
    },
  });

  const formattedRequests = requests.map((request) => {
    const profile = request.user_friendship_initiatorIdTouser.profile;
    return {
      id: request.id,
      userId: request.user_friendship_initiatorIdTouser.id,
      email: request.user_friendship_initiatorIdTouser.email,
      displayName: profile?.displayName || request.user_friendship_initiatorIdTouser.email?.split("@")[0] || "User",
      avatar: profile?.avatar || null,
      bio: profile?.bio || null,
      requestedAt: request.createdAt,
    };
  });

  return c.json({ requests: formattedRequests });
});

// ============================================
// POST /api/friends/request - Send friend request
// ============================================
const sendRequestSchema = z.object({
  userId: z.string(),
});

friendsRouter.post("/request", zValidator("json", sendRequestSchema), async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const { userId } = c.req.valid("json");

  try {
    // Check if user is trying to add themselves
    if (userId === user.id) {
      return c.json({ message: "You cannot add yourself as a friend" }, 400);
    }

    // Check if user is blocked
    const isBlocked = await isUserBlocked(user.id, userId);
    const hasBlockedYou = await isUserBlocked(userId, user.id);

    if (isBlocked || hasBlockedYou) {
      return c.json({ message: "Cannot send friend request to blocked user" }, 403);
    }

    // Check if friendship already exists
    const existing = await db.friendship.findFirst({
      where: {
        OR: [
          { initiatorId: user.id, receiverId: userId },
          { initiatorId: userId, receiverId: user.id },
        ],
      },
    });

    if (existing) {
      return c.json({ message: "Friendship already exists or request already sent" }, 400);
    }

    // Create new friend request
    // ID is auto-generated by Prisma via @default(cuid())
    const friendship = await db.friendship.create({
      data: {
        initiatorId: user.id,
        receiverId: userId,
        status: "PENDING",
      },
    });
    console.log(`✅ [Friends] Friend request created from ${user.id} to ${userId}`);

    // Get sender's profile for notification
    const senderProfile = await db.profile.findUnique({
      where: { userId: user.id },
    });

    // Create notification for the receiver and send push notification
    const notification = await db.notification.create({
      data: {
        id: randomUUID(),
        userId: userId,
        senderId: user.id,
        type: "FRIEND_REQUEST",
        title: "New Friend Request",
        message: `${senderProfile?.displayName || user.email?.split("@")[0] || "Someone"} sent you a friend request`,
        data: JSON.stringify({ friendshipId: friendship.id }),
      },
    });
    console.log(`✅ [Friends] Notification created for friend request`);

    // Send push notification
    try {
      const { sendPushNotificationForNotification } = await import("../services/pushNotifications");
      await sendPushNotificationForNotification(
        userId,
        notification.title,
        notification.message,
        JSON.parse(notification.data || "{}")
      );
    } catch (error) {
      console.error("Error sending push notification for friend request:", error);
      // Continue even if push notification fails
    }

    return c.json({ success: true, friendshipId: friendship.id });
  } catch (error: unknown) {
    console.error(`❌ [Friends] Error creating friend request:`, error);
    
    // Handle Prisma unique constraint violations (duplicate friend request)
    // Check for Prisma error by checking if it has a code property
    if (error && typeof error === "object" && "code" in error) {
      const prismaError = error as { code: string; message?: string };
      if (prismaError.code === "P2002") {
        // Unique constraint violation - friend request already exists
        return c.json({ message: "Friend request already exists or request already sent" }, 400);
      }
      // Other Prisma validation errors
      if (prismaError.code.startsWith("P")) {
        return c.json({ message: "Invalid friend request data" }, 400);
      }
    }
    
    // Handle other validation errors
    if (error instanceof Error && error.message.includes("validation")) {
      return c.json({ message: "Invalid friend request data" }, 400);
    }
    
    // Log full error for debugging but don't leak internals to client
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error("Full error details:", error);
    return c.json({ message: "Failed to send friend request. Please try again." }, 500);
  }
});

// ============================================
// POST /api/friends/accept/:id - Accept friend request
// ============================================
friendsRouter.post("/accept/:id", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const friendshipId = c.req.param("id");

  // Find the friendship request
  const friendship = await db.friendship.findUnique({
    where: { id: friendshipId },
  });

  if (!friendship) {
    return c.json({ message: "Friend request not found" }, 404);
  }

  // Check if user is the receiver
  if (friendship.receiverId !== user.id) {
    return c.json({ message: "You can only accept requests sent to you" }, 403);
  }

  // Update status to ACCEPTED
  await db.friendship.update({
    where: { id: friendshipId },
    data: { status: "ACCEPTED" },
  });

  // Get accepter's profile for notification
  const accepterProfile = await db.profile.findUnique({
    where: { userId: user.id },
  });

  // Create notification for the initiator and send push notification
  const notification = await db.notification.create({
    data: {
      id: randomUUID(),
      userId: friendship.initiatorId,
      senderId: user.id,
      type: "FRIEND_ACCEPTED",
      title: "Friend Request Accepted",
      message: `${accepterProfile?.displayName || user.email?.split("@")[0] || "Someone"} accepted your friend request`,
      data: JSON.stringify({ friendshipId: friendship.id, userId: user.id }),
    },
  });

  // Send push notification
  try {
    const { sendPushNotificationForNotification } = await import("../services/pushNotifications");
    await sendPushNotificationForNotification(
      friendship.initiatorId,
      notification.title,
      notification.message,
      JSON.parse(notification.data || "{}")
    );
  } catch (error) {
    console.error("Error sending push notification for friend acceptance:", error);
    // Continue even if push notification fails
  }

  return c.json({ success: true, message: "Friend request accepted" });
});

// ============================================
// POST /api/friends/decline/:id - Decline friend request
// ============================================
friendsRouter.post("/decline/:id", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const friendshipId = c.req.param("id");

  // Find the friendship request
  const friendship = await db.friendship.findUnique({
    where: { id: friendshipId },
  });

  if (!friendship) {
    return c.json({ message: "Friend request not found" }, 404);
  }

  // Check if user is the receiver
  if (friendship.receiverId !== user.id) {
    return c.json({ message: "You can only decline requests sent to you" }, 403);
  }

  // Delete the friendship
  await db.friendship.delete({
    where: { id: friendshipId },
  });

  return c.json({ success: true, message: "Friend request declined" });
});

// ============================================
// DELETE /api/friends/:userId - Remove friend
// ============================================
friendsRouter.delete("/:userId", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const friendUserId = c.req.param("userId");

  // Find the friendship
  const friendship = await db.friendship.findFirst({
    where: {
      OR: [
        { initiatorId: user.id, receiverId: friendUserId },
        { initiatorId: friendUserId, receiverId: user.id },
      ],
    },
  });

  if (!friendship) {
    return c.json({ message: "Friendship not found" }, 404);
  }

  // Delete the friendship
  await db.friendship.delete({
    where: { id: friendship.id },
  });

  return c.json({ success: true, message: "Friend removed" });
});

// ============================================
// GET /api/friends/search - Search for users
// ============================================
const searchSchema = z.object({
  query: z.string().min(1),
});

friendsRouter.get("/search", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const query = c.req.query("query") || "";

  if (!query || query.length < 2) {
    return c.json({ users: [] });
  }

  // Search for users by email or display name
  const profiles = await db.profile.findMany({
    where: {
      AND: [
        { userId: { not: user.id } }, // Exclude current user
        {
          OR: [
            { displayName: { contains: query } },
            { user: { email: { contains: query } } },
          ],
        },
      ],
    },
    include: {
      user: true,
    },
    take: 20,
  });

  // Get user's existing friendships to mark friends
  const friendships = await db.friendship.findMany({
    where: {
      OR: [
        { initiatorId: user.id },
        { receiverId: user.id },
      ],
    },
  });

  const friendshipMap = new Map();
  friendships.forEach((f) => {
    const friendId = f.initiatorId === user.id ? f.receiverId : f.initiatorId;
    friendshipMap.set(friendId, f.status);
  });

  const users = profiles.map((profile) => ({
    id: profile.userId,
    email: profile.user.email,
    displayName: profile.displayName,
    avatar: profile.avatar,
    bio: profile.bio,
    friendshipStatus: friendshipMap.get(profile.userId) || null,
  }));

  return c.json({ users });
});

// ============================================
// GET /api/friends/recommendations - Get friend recommendations
// ============================================
friendsRouter.get("/recommendations", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  // Get user's profile to understand their interests
  const userProfile = await db.profile.findUnique({
    where: { userId: user.id },
  });

  // Get existing friendships to exclude (including pending)
  const friendships = await db.friendship.findMany({
    where: {
      OR: [
        { initiatorId: user.id },
        { receiverId: user.id },
      ],
    },
  });

  const friendUserIds = friendships.map((f) =>
    f.initiatorId === user.id ? f.receiverId : f.initiatorId
  );

  // Get user's friends for mutual friends calculation
  const userFriends = friendships
    .filter((f) => f.status === "ACCEPTED")
    .map((f) => (f.initiatorId === user.id ? f.receiverId : f.initiatorId));

  // Find profiles with similar interests or nearby location
  const recommendations = await db.profile.findMany({
    where: {
      AND: [
        { userId: { not: user.id } }, // Exclude current user
        { userId: { notIn: friendUserIds } }, // Exclude existing friends and pending requests
        { onboardingCompleted: true }, // Only show users who completed onboarding
      ],
    },
    include: {
      user: true,
    },
    take: 50, // Get more to calculate mutual friends
  });

  // Calculate mutual friends for each recommendation
  const recommendationsWithMutuals = await Promise.all(
    recommendations.map(async (profile) => {
      // Get this user's friends
      const theirFriendships = await db.friendship.findMany({
        where: {
          OR: [
            { initiatorId: profile.userId, status: "ACCEPTED" },
            { receiverId: profile.userId, status: "ACCEPTED" },
          ],
        },
      });

      const theirFriends = theirFriendships.map((f) =>
        f.initiatorId === profile.userId ? f.receiverId : f.initiatorId
      );

      // Calculate mutual friends
      const mutualFriends = userFriends.filter((friendId) => theirFriends.includes(friendId));
      const mutualFriendsCount = mutualFriends.length;

      // Get mutual friends profiles for display
      const mutualFriendsProfiles = await db.profile.findMany({
        where: { userId: { in: mutualFriends.slice(0, 3) } },
        select: { displayName: true, avatar: true },
      });

      return {
        profile,
        mutualFriendsCount,
        mutualFriends: mutualFriendsProfiles,
      };
    })
  );

  const users = recommendationsWithMutuals.map(({ profile, mutualFriendsCount, mutualFriends }) => {
    const interests = profile.interests ? JSON.parse(profile.interests) : [];
    const userInterests = userProfile?.interests ? JSON.parse(userProfile.interests) : [];

    // Calculate interest match score
    const sharedInterests = interests.filter((i: string) => userInterests.includes(i));
    const matchScore = sharedInterests.length;

    // Calculate total recommendation score (mutual friends weighted more)
    const recommendationScore = mutualFriendsCount * 3 + matchScore;

    // Generate reason text
    let reason = "";
    if (mutualFriendsCount > 0) {
      reason = `${mutualFriendsCount} mutual friend${mutualFriendsCount > 1 ? "s" : ""}`;
    } else if (matchScore > 0) {
      reason = "Similar interests";
    } else {
      reason = "New to Rejection Hero";
    }

    return {
      id: profile.userId,
      email: profile.user.email,
      displayName: profile.displayName,
      avatar: profile.avatar,
      bio: profile.bio,
      interests,
      sharedInterests,
      matchScore,
      location: profile.location,
      mutualFriendsCount,
      mutualFriends: mutualFriends.map((mf) => ({
        displayName: mf.displayName,
        avatar: mf.avatar,
      })),
      reason,
      recommendationScore,
    };
  }).sort((a, b) => b.recommendationScore - a.recommendationScore).slice(0, 10); // Sort by recommendation score and take top 10

  return c.json({ recommendations: users });
});

// ============================================
// GET /api/friends/status/:userId - Get friendship status with a specific user
// ============================================
friendsRouter.get("/status/:userId", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const otherUserId = c.req.param("userId");

  // Check if friendship exists
  const friendship = await db.friendship.findFirst({
    where: {
      OR: [
        { initiatorId: user.id, receiverId: otherUserId },
        { initiatorId: otherUserId, receiverId: user.id },
      ],
    },
  });

  if (!friendship) {
    return c.json({ status: "NONE" });
  }

  // Determine status based on friendship state and who initiated
  let status: "PENDING_SENT" | "PENDING_RECEIVED" | "FRIENDS" = "FRIENDS";
  
  if (friendship.status === "PENDING") {
    if (friendship.initiatorId === user.id) {
      status = "PENDING_SENT";
    } else {
      status = "PENDING_RECEIVED";
    }
  }

  return c.json({ status, friendshipId: friendship.id });
});

export { friendsRouter };
