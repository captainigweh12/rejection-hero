import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";
import { randomUUID } from "node:crypto";
import { type AppType } from "../types";
import { db } from "../db";
import { createMomentRequestSchema } from "../../../shared/contracts";

const momentsRouter = new Hono<AppType>();

// ============================================
// POST /api/moments - Create a moment/story
// ============================================
momentsRouter.post("/", zValidator("json", createMomentRequestSchema), async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const { imageUrl, videoUrl, content, groupId } = c.req.valid("json");

  // Validate that at least one content type is provided
  if (!imageUrl && !videoUrl && !content) {
    return c.json({ message: "Moment must have either an image, video, or text content" }, 400);
  }

  // If groupId provided, verify user is a member
  if (groupId) {
    const membership = await db.group_member.findUnique({
      where: {
        groupId_userId: {
          groupId,
          userId: user.id,
        },
      },
    });

    if (!membership) {
      return c.json({ message: "You must be a member of this group to post stories" }, 403);
    }
  }

  try {
    // Create moment that expires in 24 hours
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 24);

    const moment = await db.moment.create({
      data: {
        // ID is auto-generated by Prisma via @default(cuid())
        userId: user.id,
        groupId: groupId || null,
        imageUrl: imageUrl || null,
        videoUrl: videoUrl || null,
        content: content || null,
        expiresAt,
      },
    });

    return c.json({
      id: moment.id,
      imageUrl: moment.imageUrl,
      videoUrl: moment.videoUrl,
      content: moment.content,
      expiresAt: moment.expiresAt.toISOString(),
      createdAt: moment.createdAt.toISOString(),
    });
  } catch (error) {
    console.error("Create moment error:", error);
    return c.json({ message: "Failed to create moment" }, 500);
  }
});

// ============================================
// GET /api/moments - Get active moments from friends
// ============================================
momentsRouter.get("/", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  try {
    // Get user's friends
    const friendships = await db.friendship.findMany({
      where: {
        OR: [
          { initiatorId: user.id, status: "ACCEPTED" },
          { receiverId: user.id, status: "ACCEPTED" },
        ],
      },
    });

    const friendIds = friendships.map((f) =>
      f.initiatorId === user.id ? f.receiverId : f.initiatorId
    );

    // Include user's own ID to show their moments too
    const userIds = [user.id, ...friendIds];

    // Get active moments (not expired) from friends and self (exclude group moments)
    const now = new Date();
    const moments = await db.moment.findMany({
      where: {
        userId: { in: userIds },
        groupId: null, // Only personal moments, not group moments
        expiresAt: { gt: now },
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            image: true,
            profile: {
              select: {
                displayName: true,
                avatar: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // Group moments by user
    const momentsByUser = moments.reduce(
      (acc, moment) => {
        const userId = moment.userId;
        if (!acc[userId]) {
          acc[userId] = {
            userId: moment.user.id,
            userName: moment.user.Profile?.displayName || moment.user.name,
            userAvatar: moment.user.Profile?.avatar || moment.user.image,
            moments: [],
          };
        }
        acc[userId].moments.push({
          id: moment.id,
          imageUrl: moment.imageUrl,
          videoUrl: moment.videoUrl,
          content: moment.content,
          expiresAt: moment.expiresAt.toISOString(),
          createdAt: moment.createdAt.toISOString(),
        });
        return acc;
      },
      {} as Record<
        string,
        {
          userId: string;
          userName: string | null;
          userAvatar: string | null;
          moments: Array<{
            id: string;
            imageUrl: string | null;
            videoUrl: string | null;
            content: string | null;
            expiresAt: string;
            createdAt: string;
          }>;
        }
      >
    );

    // Convert to array
    const formattedMoments = Object.values(momentsByUser);

    return c.json({
      moments: formattedMoments,
    });
  } catch (error) {
    console.error("Get moments error:", error);
    return c.json({ message: "Failed to fetch moments" }, 500);
  }
});

// ============================================
// DELETE /api/moments/:id - Delete a moment
// ============================================
momentsRouter.delete("/:id", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const momentId = c.req.param("id");

  try {
    // Verify moment exists and belongs to user
    const moment = await db.moment.findUnique({
      where: { id: momentId },
    });

    if (!moment) {
      return c.json({ message: "Moment not found" }, 404);
    }

    if (moment.userId !== user.id) {
      return c.json({ message: "You can only delete your own moments" }, 403);
    }

    // Delete moment
    await db.moment.delete({
      where: { id: momentId },
    });

    return c.json({
      success: true,
    });
  } catch (error) {
    console.error("Delete moment error:", error);
    return c.json({ message: "Failed to delete moment" }, 500);
  }
});

// ============================================
// POST /api/moments/:id/like - Toggle like on a moment
// ============================================
momentsRouter.post("/:id/like", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const momentId = c.req.param("id");

  try {
    // Check if moment exists
    const moment = await db.moment.findUnique({
      where: { id: momentId },
    });

    if (!moment) {
      return c.json({ message: "Moment not found" }, 404);
    }

    // Check if already liked
    const existingLike = await db.moment_like.findUnique({
      where: {
        momentId_userId: {
          momentId,
          userId: user.id,
        },
      },
    });

    if (existingLike) {
      // Unlike
      await db.moment_like.delete({
        where: {
          momentId_userId: {
            momentId,
            userId: user.id,
          },
        },
      });
      return c.json({ liked: false, likeCount: await db.moment_like.count({ where: { momentId } }) });
    } else {
      // Like
      await db.moment_like.create({
        data: {
          momentId,
          userId: user.id,
        },
      });
      return c.json({ liked: true, likeCount: await db.moment_like.count({ where: { momentId } }) });
    }
  } catch (error) {
    console.error("Toggle like error:", error);
    return c.json({ message: "Failed to toggle like" }, 500);
  }
});

// ============================================
// GET /api/moments/:id/likes - Get like count and user's like status
// ============================================
momentsRouter.get("/:id/likes", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const momentId = c.req.param("id");

  try {
    const likeCount = await db.moment_like.count({
      where: { momentId },
    });

    const userLiked = await db.moment_like.findUnique({
      where: {
        momentId_userId: {
          momentId,
          userId: user.id,
        },
      },
    });

    return c.json({
      likeCount,
      liked: !!userLiked,
    });
  } catch (error) {
    console.error("Get likes error:", error);
    return c.json({ message: "Failed to get likes" }, 500);
  }
});

// ============================================
// POST /api/moments/:id/view - Record that user viewed the moment
// ============================================
momentsRouter.post("/:id/view", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const momentId = c.req.param("id");

  try {
    // Check if moment exists
    const moment = await db.moment.findUnique({
      where: { id: momentId },
    });

    if (!moment) {
      return c.json({ message: "Moment not found" }, 404);
    }

    // Check if already viewed (idempotent)
    const existingView = await db.moment_view.findUnique({
      where: {
        momentId_userId: {
          momentId,
          userId: user.id,
        },
      },
    });

    if (!existingView) {
      // Record view
      await db.moment_view.create({
        data: {
          momentId,
          userId: user.id,
        },
      });
    }

    return c.json({ success: true });
  } catch (error) {
    console.error("Record view error:", error);
    return c.json({ message: "Failed to record view" }, 500);
  }
});

// ============================================
// GET /api/moments/:id/viewers - Get list of users who viewed the moment (only for owner)
// ============================================
momentsRouter.get("/:id/viewers", async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const momentId = c.req.param("id");

  try {
    // Check if moment exists and user is the owner
    const moment = await db.moment.findUnique({
      where: { id: momentId },
    });

    if (!moment) {
      return c.json({ message: "Moment not found" }, 404);
    }

    if (moment.userId !== user.id) {
      return c.json({ message: "You can only view viewers of your own moments" }, 403);
    }

    // Get viewers
    const views = await db.moment_view.findMany({
      where: { momentId },
      include: {
        user: {
          include: {
            profile: true,
          },
        },
      },
      orderBy: {
        viewedAt: "desc",
      },
    });

    const viewers = views.map((view) => ({
      userId: view.user.id,
      displayName: view.user.profile?.displayName || view.user.email?.split("@")[0] || "User",
      avatar: view.user.profile?.avatar || view.user.image || null,
      viewedAt: view.viewedAt.toISOString(),
    }));

    return c.json({ viewers });
  } catch (error) {
    console.error("Get viewers error:", error);
    return c.json({ message: "Failed to get viewers" }, 500);
  }
});

// ============================================
// POST /api/moments/:id/message - Send a DM to the story creator
// ============================================
momentsRouter.post("/:id/message", zValidator("json", z.object({ message: z.string().min(1).max(1000) })), async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const momentId = c.req.param("id");
  const { message } = c.req.valid("json");

  try {
    // Get moment and creator
    const moment = await db.moment.findUnique({
      where: { id: momentId },
      include: {
        user: true,
      },
    });

    if (!moment) {
      return c.json({ message: "Moment not found" }, 404);
    }

    const creatorId = moment.userId;

    // Check if users are friends (required for messaging)
    const friendship = await db.friendship.findFirst({
      where: {
        OR: [
          { initiatorId: user.id, receiverId: creatorId, status: "ACCEPTED" },
          { initiatorId: creatorId, receiverId: user.id, status: "ACCEPTED" },
        ],
      },
    });

    if (!friendship) {
      return c.json({ message: "You can only message friends. Send a friend request first." }, 403);
    }

    // Create message with "Story reply:" prefix
    const messageContent = `Story reply: ${message}`;

    await db.message.create({
      data: {
        id: randomUUID(),
        senderId: user.id,
        receiverId: creatorId,
        content: messageContent,
      },
    });

    return c.json({ success: true, message: "Message sent" });
  } catch (error) {
    console.error("Send message error:", error);
    return c.json({ message: "Failed to send message" }, 500);
  }
});

// ============================================
// POST /api/moments/:id/send-quest - Send a quest to the story creator
// ============================================
momentsRouter.post("/:id/send-quest", zValidator("json", z.object({ questId: z.string() })), async (c) => {
  const user = c.get("user");

  if (!user) {
    return c.json({ message: "Unauthorized" }, 401);
  }

  const momentId = c.req.param("id");
  const { questId } = c.req.valid("json");

  try {
    // Get moment and creator
    const moment = await db.moment.findUnique({
      where: { id: momentId },
    });

    if (!moment) {
      return c.json({ message: "Moment not found" }, 404);
    }

    const creatorId = moment.userId;

    // Check if quest exists
    const quest = await db.quest.findUnique({
      where: { id: questId },
    });

    if (!quest) {
      return c.json({ message: "Quest not found" }, 404);
    }

    // Check if users are friends (required for sending quests)
    const friendship = await db.friendship.findFirst({
      where: {
        OR: [
          { initiatorId: user.id, receiverId: creatorId, status: "ACCEPTED" },
          { initiatorId: creatorId, receiverId: user.id, status: "ACCEPTED" },
        ],
      },
    });

    if (!friendship) {
      return c.json({ message: "You can only send quests to friends. Send a friend request first." }, 403);
    }

    // Use existing shared quest system
    const { shareQuestWithFriend } = await import("./sharedQuests");
    // For now, create shared quest directly
    const sharedQuest = await db.shared_quest.create({
      data: {
        id: randomUUID(),
        senderId: user.id,
        receiverId: creatorId,
        questId,
        message: `Sent from story`,
        status: "pending",
      },
    });

    return c.json({ success: true, sharedQuestId: sharedQuest.id });
  } catch (error) {
    console.error("Send quest error:", error);
    return c.json({ message: "Failed to send quest" }, 500);
  }
});

export default momentsRouter;
